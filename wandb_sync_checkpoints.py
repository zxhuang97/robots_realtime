"""
W&B Artifact Sync Tool

Sync checkpoints to/from Weights & Biases Artifacts.

Key Concepts:
- Artifact Name: The name of the artifact (e.g., "1224_xdof_handoff")
- Version: Auto-generated by W&B (v0, v1, v2, ...) - increments with each upload
- Alias: User-friendly tags you attach to versions (e.g., "step24000-hf", "best")
  - Multiple checkpoints from the same run can use the same artifact name with different aliases
  - Different runs can use different artifact names with the same alias (no conflict)

Usage:
  python wandb_sync_checkpoints.py <action> [path] [options]

Actions:
  upload   - Upload a checkpoint directory/file to W&B
  download - Download a checkpoint from W&B to local directory
  list     - List all versions of an artifact with their aliases

Examples:
  # ===== UPLOAD =====
  # Upload a checkpoint folder (creates version v0)
  python wandb_sync_checkpoints.py upload ./checkpoints/my_model --name my-model-checkpoint

  # Upload a checkpoint with an alias (e.g., step number)
  python wandb_sync_checkpoints.py upload ./checkpoints/step24000-hf --name 1224_xdof_handoff --alias step24000-hf

  # Upload multiple checkpoints from the same run
  # Each upload creates a new version (v0, v1, v2, ...) with its own alias
  python wandb_sync_checkpoints.py upload ./checkpoints/step24000-hf --name 1224_xdof_handoff --alias step24000-hf
  python wandb_sync_checkpoints.py upload ./checkpoints/step48000-hf --name 1224_xdof_handoff --alias step48000-hf
  python wandb_sync_checkpoints.py upload ./checkpoints/step72000-hf --name 1224_xdof_handoff --alias step72000-hf

  # Upload checkpoints from different runs (different artifact names, same alias is fine)
  python wandb_sync_checkpoints.py upload ./checkpoints/1224/step24000-hf --name 1224_xdof_handoff --alias step24000-hf
  python wandb_sync_checkpoints.py upload ./checkpoints/1226/step24000-hf --name 1226_xdof_handoff --alias step24000-hf

  # ===== LIST =====
  # List all versions of an artifact (shows version numbers and aliases)
  python wandb_sync_checkpoints.py list --name 1224_xdof_handoff
  # Output:
  #   v0: step24000-hf
  #   v1: step48000-hf
  #   v2: step72000-hf

  # ===== DOWNLOAD =====
  # Download the latest version of a checkpoint
  python wandb_sync_checkpoints.py download ./downloaded_checkpoints --name 1224_xdof_handoff

  # Download a specific version by alias (recommended - easier to remember)
  python wandb_sync_checkpoints.py download ./downloaded_checkpoints --name 1224_xdof_handoff --version step24000-hf

  # Download a specific version by version number (use list to find version numbers)
  python wandb_sync_checkpoints.py download ./downloaded_checkpoints --name 1224_xdof_handoff --version v0
"""
import argparse
import os
import sys
import wandb
from pathlib import Path

def upload_checkpoint(
    path: str,
    project: str,
    entity: str,
    artifact_name: str,
    artifact_type: str = "model",
    description: str = None,
    aliases: list[str] = None
):
    """
    Uploads a local directory or file as a W&B artifact.
    
    Each upload creates a new version of the artifact (v0, v1, v2, etc.).
    Aliases are user-friendly tags you can attach to versions (e.g., "step24000-hf", "best").
    Multiple checkpoints from the same run can share the same artifact name with different aliases.
    
    Args:
        path: Local path to directory or file to upload
        project: W&B project name
        entity: W&B entity (username or team name)
        artifact_name: Name of the artifact (e.g., "1224_xdof_handoff")
        artifact_type: Type of artifact (default: "model")
        description: Optional description for the artifact
        aliases: List of aliases to tag this version with (e.g., ["step24000-hf"])
    """
    path = Path(path).resolve()
    if not path.exists():
        print(f"Error: Path '{path}' does not exist.")
        sys.exit(1)

    # Use the artifact name as the run name for easier identification, 
    # but append a timestamp or similar if needed to avoid collisions 
    # if we were tracking metrics. For uploads, collisions are fine/handled.
    # actually, let's just let W&B pick a fun name, or use "upload-{artifact_name}"
    run_name = f"upload-{artifact_name}"

    print(f"Initializing W&B run for upload...")
    run = wandb.init(
        project=project,
        entity=entity,
        job_type="upload-checkpoint",
        name=run_name,
        # id=run_id, # Removed complexity
        resume="allow"
    )

    print(f"Creating artifact '{artifact_name}' (type: {artifact_type})...")
    artifact = wandb.Artifact(
        name=artifact_name,
        type=artifact_type,
        description=description
    )

    if path.is_dir():
        print(f"Adding directory {path} to artifact...")
        artifact.add_dir(str(path))
    else:
        print(f"Adding file {path} to artifact...")
        artifact.add_file(str(path))

    print("Logging artifact (this starts the upload)...")
    # Each upload creates a new version (v0, v1, v2, etc.) automatically
    # Aliases are tags attached to this specific version
    run.log_artifact(artifact, aliases=aliases or [])
    
    # Wait for the artifact to finish uploading
    print("Waiting for upload to complete...")
    artifact.wait()
    
    run.finish()
    print(f"Successfully uploaded to {entity}/{project}/{artifact_name}")
    if aliases:
        print(f"Tagged with aliases: {', '.join(aliases)}")


def list_checkpoints(
    project: str,
    entity: str,
    artifact_name: str,
    artifact_type: str = "model"
):
    """
    Lists all versions of a W&B artifact with their aliases and descriptions.
    
    Shows the version number (v0, v1, v2, etc.) and any aliases attached to each version.
    Versions are auto-generated by W&B and increment with each upload.
    
    Args:
        project: W&B project name
        entity: W&B entity (username or team name)
        artifact_name: Name of the artifact to list
        artifact_type: Type of artifact (default: "model")
    """
    api = wandb.Api()
    print(f"Listing versions of '{entity}/{project}/{artifact_name}'...\n")
    
    try:
        # Get the artifact collection (all versions)
        artifact_collection = api.artifact_type(type_name=artifact_type, project=project)
        artifact_obj = artifact_collection[artifact_name]
        
        versions = list(artifact_obj.versions())
        if not versions:
            print(f"No versions found for artifact '{artifact_name}'")
            return
        
        print(f"Found {len(versions)} version(s):\n")
        for version in versions:
            aliases = version.aliases
            alias_str = ", ".join(aliases) if aliases else "(no aliases)"
            print(f"  {version.version}: {alias_str}")
            if version.description:
                print(f"    Description: {version.description}")
            print()
            
    except KeyError:
        print(f"Error: Artifact '{artifact_name}' not found in {entity}/{project}")
        sys.exit(1)
    except Exception as e:
        print(f"Error listing artifact: {e}")
        sys.exit(1)


def download_checkpoint(
    path: str,
    project: str,
    entity: str,
    artifact_name: str,
    version: str = "latest"
):
    """
    Downloads a W&B artifact to a local directory.
    
    The version parameter can be:
    - An alias (e.g., "step24000-hf") - recommended for easy identification
    - A version number (e.g., "v3") - use list_checkpoints() to find version numbers
    - "latest" (default) - downloads the most recent version
    
    Args:
        path: Base local directory path to download the artifact to (will create a subdirectory with the artifact name and version)
        project: W&B project name
        entity: W&B entity (username or team name)
        artifact_name: Name of the artifact to download
        version: Version identifier - can be an alias, version number, or "latest"
    """
    print(f"Initializing W&B run for download...")
    run = wandb.init(
        project=project,
        entity=entity,
        job_type="download-checkpoint",
        name=f"download-{artifact_name}"
    )

    # Version can be: an alias (e.g., "step24000-hf"), a version number (e.g., "v3"), or "latest"
    artifact_path = f"{entity}/{project}/{artifact_name}:{version}"
    print(f"Downloading artifact '{artifact_path}'...")
    
    try:
        artifact = run.use_artifact(artifact_path)
        # Download into a subdirectory named after the artifact and version
        download_path = os.path.join(path, f"{artifact_name}_{version}")
        download_dir = artifact.download(root=download_path)
        print(f"Successfully downloaded artifact to '{download_dir}'")
    except Exception as e:
        print(f"Error downloading artifact: {e}")
        sys.exit(1)
    finally:
        run.finish()

def main():
    parser = argparse.ArgumentParser(
        description="Sync checkpoints (upload/download/list) using Weights & Biases Artifacts.",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        "action",
        choices=["upload", "download", "list"],
        help="Action to perform: upload, download, or list."
    )
    parser.add_argument(
        "path",
        nargs="?",
        help="Local path. For upload: source directory/file. For download: destination directory. Not needed for list."
    )
    parser.add_argument(
        "--project",
        default="flow_checkpoints",
        help="W&B project name. Defaults to WANDB_PROJECT env var."
    )
    parser.add_argument(
        "--entity",
        default="far-wandb",
        help="W&B entity (username or team name). Defaults to WANDB_ENTITY env var."
    )
    parser.add_argument(
        "--name",
        dest="artifact_name",
        help="Name of the artifact. Defaults to the directory name if not provided."
    )
    parser.add_argument(
        "--type",
        dest="artifact_type",
        default="model",
        help="Type of the artifact (default: model). Used for upload and list."
    )
    parser.add_argument(
        "--version",
        default="latest",
        help="Artifact version or alias to download (default: latest). Used only for download."
    )
    parser.add_argument(
        "--description",
        help="Description for the artifact. Used only for upload."
    )
    # Removed --run-name and --run-id to simplify
    parser.add_argument(
        "--alias",
        action="append",
        dest="aliases",
        help="Alias for the artifact (can be used multiple times). Used only for upload."
    )

    args = parser.parse_args()

    if not args.project:
        parser.error("The --project argument or WANDB_PROJECT environment variable is required.")
    if not args.entity:
        parser.error("The --entity argument or WANDB_ENTITY environment variable is required.")

    # Handle different actions
    if args.action == "list":
        if not args.artifact_name:
            parser.error("The --name argument is required for the list action.")
        list_checkpoints(
            project=args.project,
            entity=args.entity,
            artifact_name=args.artifact_name,
            artifact_type=args.artifact_type
        )
    else:
        # For upload and download, path is required
        if not args.path:
            parser.error(f"The path argument is required for the {args.action} action.")
        
        # Determine artifact name from path if not provided
        if not args.artifact_name:
            args.artifact_name = os.path.basename(os.path.normpath(args.path))

        # Check for WANDB_API_KEY or login
        if "WANDB_API_KEY" not in os.environ:
            # We can't easily check if they are logged in via 'wandb login' programmatically without side effects
            # but wandb.init will throw/prompt if not authenticated.
            pass

        if args.action == "upload":
            upload_checkpoint(
                path=args.path,
                project=args.project,
                entity=args.entity,
                artifact_name=args.artifact_name,
                artifact_type=args.artifact_type,
                description=args.description,
                aliases=args.aliases
            )
        elif args.action == "download":
            download_checkpoint(
                path=args.path,
                project=args.project,
                entity=args.entity,
                artifact_name=args.artifact_name,
                version=args.version,
            )

if __name__ == "__main__":
    main()

